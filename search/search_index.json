{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Redux Agent declarative, middleware-free effect model \u00b6 In UI development, React lets you describe the interface and have the machine worry about drawing it. A simple and powerful model which unfortunately stops at visual I/O. Non-visual I/O such as network requests is usually done in thunks/sagas/epics (scattering logic across middlewares and reducers) or in UI components (coupling them to remote APIs). Redux Agent extends React\u2019s model to non-visual I/O : describe a network request, a storage operation, a websocket message, \u2026 and let the machine worry about performing it. Logic stays in the reducer, components stay lightweight, and it\u2019s easy to see what state triggers which effect. Redux Agent clocks at just 3kB. It doesn\u2019t introduce middlewares and doesn\u2019t involve exotic concepts; it has only one basic abstraction (the \u201ctask\u201d) and works wherever Redux does, regardless of UI framework. Typical usage is as simple as: import { addTask } from 'redux-agent' const getTodo = (id) => ({ type: 'http', method: 'get', url: `https://jsonplaceholder.typicode.com/todos/${id}`, actions: { success: 'FETCH_TODO_SUCCESS', failure: 'FETCH_TODO_FAILURE' } }) const reducer = (state, action) => { switch(action.type) { case 'FETCH_TODO': return addTask(state, getTodo(1)) case 'FETCH_TODO_SUCCESS': return { ...state, items: [ ...state.items, action.payload ] } Try it \u00b6 See Redux Agent in action in one of these interactive examples: HTTP Requests Timers Random Number Generation WebSocket Messaging DOM Storage ( coming soon ) Q&A \u00b6 \u201cI thought that the reducer should stay free from side effects?\u201d Yes. In fact, addTask in the example above doesn\u2019t perform any effect, it only stores a task description in the state which is later used by the runtime to perform the effect, just like you normally store data in the state which is later used to render the UI. \u201cWhat if I want to not just add a task but also modify the state in other ways?\u201d addTask simply returns a new state that includes the desired task. You can derive further states as usual: case 'FETCH_TODO': const s1 = addTask(state, getTodo(1)) return { ...s1, isLoading: true } Or make it even easier on the eyes with Redux Agent\u2019s built-in support for Immer . \u201cHow well does it scale to complex flows?\u201d Redux Agent provides building blocks and is not prescriptive about how you arrange them. That said, one style it turned out to be a great fit for is state charts, see (draft) Writing a robust, reusable login flow with redux\u2011agent and state charts for an example. \u201cIs this similar to Elm?\u201d Quite. But whereas Elm\u2019s reducer returns the new state plus commands, Redux Agent considers active tasks an integral part of the application state and therefore keeps them in the state tree. \u201cIs this similar to redux-loop?\u201d Yes and no. Yes, since both make the reducer the single source of logic. No, since redux-loop changes the reducer\u2019s API so it can return state plus \u201ccommands\u201d (like Elm), whereas Redux Agent uses vanilla Redux APIs. Documentation \u00b6 Quickstart Tutorial Limitations Immer Support Reference: HTTP : Send HTTP requests and track responses. Uses window.fetch under the hood WebSocket : Connect to websocket endpoints, send and listen to messages Storage : Write to and read from DOM storage RNG : Generate random numbers Timer : Dispatch an action at an interval License \u00b6 MIT Credits \u00b6 reduceReducers by Tim Cheung . Icon by Setyo Ari Wibowo .","title":"Home"},{"location":"#redux-agent-declarative-middleware-free-effect-model","text":"In UI development, React lets you describe the interface and have the machine worry about drawing it. A simple and powerful model which unfortunately stops at visual I/O. Non-visual I/O such as network requests is usually done in thunks/sagas/epics (scattering logic across middlewares and reducers) or in UI components (coupling them to remote APIs). Redux Agent extends React\u2019s model to non-visual I/O : describe a network request, a storage operation, a websocket message, \u2026 and let the machine worry about performing it. Logic stays in the reducer, components stay lightweight, and it\u2019s easy to see what state triggers which effect. Redux Agent clocks at just 3kB. It doesn\u2019t introduce middlewares and doesn\u2019t involve exotic concepts; it has only one basic abstraction (the \u201ctask\u201d) and works wherever Redux does, regardless of UI framework. Typical usage is as simple as: import { addTask } from 'redux-agent' const getTodo = (id) => ({ type: 'http', method: 'get', url: `https://jsonplaceholder.typicode.com/todos/${id}`, actions: { success: 'FETCH_TODO_SUCCESS', failure: 'FETCH_TODO_FAILURE' } }) const reducer = (state, action) => { switch(action.type) { case 'FETCH_TODO': return addTask(state, getTodo(1)) case 'FETCH_TODO_SUCCESS': return { ...state, items: [ ...state.items, action.payload ] }","title":"Redux Agent \u00a0declarative, middleware-free effect model"},{"location":"#try-it","text":"See Redux Agent in action in one of these interactive examples: HTTP Requests Timers Random Number Generation WebSocket Messaging DOM Storage ( coming soon )","title":"Try it"},{"location":"#qa","text":"\u201cI thought that the reducer should stay free from side effects?\u201d Yes. In fact, addTask in the example above doesn\u2019t perform any effect, it only stores a task description in the state which is later used by the runtime to perform the effect, just like you normally store data in the state which is later used to render the UI. \u201cWhat if I want to not just add a task but also modify the state in other ways?\u201d addTask simply returns a new state that includes the desired task. You can derive further states as usual: case 'FETCH_TODO': const s1 = addTask(state, getTodo(1)) return { ...s1, isLoading: true } Or make it even easier on the eyes with Redux Agent\u2019s built-in support for Immer . \u201cHow well does it scale to complex flows?\u201d Redux Agent provides building blocks and is not prescriptive about how you arrange them. That said, one style it turned out to be a great fit for is state charts, see (draft) Writing a robust, reusable login flow with redux\u2011agent and state charts for an example. \u201cIs this similar to Elm?\u201d Quite. But whereas Elm\u2019s reducer returns the new state plus commands, Redux Agent considers active tasks an integral part of the application state and therefore keeps them in the state tree. \u201cIs this similar to redux-loop?\u201d Yes and no. Yes, since both make the reducer the single source of logic. No, since redux-loop changes the reducer\u2019s API so it can return state plus \u201ccommands\u201d (like Elm), whereas Redux Agent uses vanilla Redux APIs.","title":"Q&amp;A"},{"location":"#documentation","text":"Quickstart Tutorial Limitations Immer Support Reference: HTTP : Send HTTP requests and track responses. Uses window.fetch under the hood WebSocket : Connect to websocket endpoints, send and listen to messages Storage : Write to and read from DOM storage RNG : Generate random numbers Timer : Dispatch an action at an interval","title":"Documentation"},{"location":"#license","text":"MIT","title":"License"},{"location":"#credits","text":"reduceReducers by Tim Cheung . Icon by Setyo Ari Wibowo .","title":"Credits"},{"location":"license/","text":"MIT License Copyright \u00a9 2019 Massimiliano Mirra Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"limitations/","text":"Limitations \u00b6 Tasks are stored in a top-level member of the Redux state, therefore they can only be managed from reducers that have access to the entire state tree. That rules out reducers included via combineReducers . See Beyond combineReducers in the official Redux documentation. Time traveling in Redux devtools is currently not supported but on the roadmap. Tracing and inspection works as usual.","title":"Limitations"},{"location":"limitations/#limitations","text":"Tasks are stored in a top-level member of the Redux state, therefore they can only be managed from reducers that have access to the entire state tree. That rules out reducers included via combineReducers . See Beyond combineReducers in the official Redux documentation. Time traveling in Redux devtools is currently not supported but on the roadmap. Tracing and inspection works as usual.","title":"Limitations"},{"location":"quickstart/","text":"Installation \u00b6 yarn add redux-agent Or: npm i redux-agent TypeScript definitions are included. Adding to your project \u00b6 Import the agents near to where the store is configured: import { createStore } from 'redux' + import { configureAgents, createHttpAgent } from 'redux-agent' import reducer from './reducers' const store = createStore(reducer) + store.subscribe(configureAgents([ createHttpAgent() ], store)) Import the helpers in your reducer: + import { + addTask, reduceReducers, taskReducer + } from 'redux-agent' const reducer = (state, action) => { switch(action.type) { Concatenate your reducer with taskReducer : } } - export default reducer + export default reduceReducers(reducer, taskReducer) That\u2019s all. Now you can create tasks and drive effects from the reducer: switch(action.type) { case 'FETCH_TODO': return addTask({ type: 'http', method: 'get', url: 'https://jsonplaceholder.typicode.com/todos/1', actions: { success: 'FETCH_TODO_SUCCESS', failure: 'FETCH_TODO_FAILURE' } }) Next steps \u00b6 Build a simple app following the the tutorial . See more examples in the interactive demos .","title":"Quickstart"},{"location":"quickstart/#installation","text":"yarn add redux-agent Or: npm i redux-agent TypeScript definitions are included.","title":"Installation"},{"location":"quickstart/#adding-to-your-project","text":"Import the agents near to where the store is configured: import { createStore } from 'redux' + import { configureAgents, createHttpAgent } from 'redux-agent' import reducer from './reducers' const store = createStore(reducer) + store.subscribe(configureAgents([ createHttpAgent() ], store)) Import the helpers in your reducer: + import { + addTask, reduceReducers, taskReducer + } from 'redux-agent' const reducer = (state, action) => { switch(action.type) { Concatenate your reducer with taskReducer : } } - export default reducer + export default reduceReducers(reducer, taskReducer) That\u2019s all. Now you can create tasks and drive effects from the reducer: switch(action.type) { case 'FETCH_TODO': return addTask({ type: 'http', method: 'get', url: 'https://jsonplaceholder.typicode.com/todos/1', actions: { success: 'FETCH_TODO_SUCCESS', failure: 'FETCH_TODO_FAILURE' } })","title":"Adding to your project"},{"location":"quickstart/#next-steps","text":"Build a simple app following the the tutorial . See more examples in the interactive demos .","title":"Next steps"},{"location":"related-material/","text":"Here are listed some articles and projects which suggest or implement approaches similar to redux-agent , if not in strategy at least in spirit. Amusingly, many were discovered when looking for an available name in the very crowded redux-* npm namespace. https://github.com/winstonewert/redux-reactions https://github.com/ccorcos/elmish https://github.com/redux-effects/redux-effects https://www.npmjs.com/package/human-redux-reactor https://read.reduxbook.com/markdown/part2/10-reactive-state.html https://github.com/redux-loop/redux-loop http://jamesknelson.com/join-the-dark-side-of-the-flux-responding-to-actions-with-actors/ https://kyleshevlin.com/renderless-components https://github.com/xaviervia/redux-haiku https://www.npmjs.com/package/redux-agents https://github.com/batata-frita/redux-heat","title":"Related material"},{"location":"tutorial/","text":"Tutorial \u00b6 We\u2019ll make a simple \u201cwhen the user clicks this button, fetch a remote resource and display it\u201d application using Redux Agent and the HTTP task. We\u2019ll use a React app, but Redux Agent does not rely on React and works along any other UI runtime. A skeleton app \u00b6 Create a skeleton with create-react-app : $ yarn create react-app agent-tutorial Or: $ npx create-react-app agent-tutorial Install redux , redux-agent , react-redux , and redux-logger . $ cd agent-tutorial yarn add --dev redux react-redux redux-logger redux-agent Set up the entry point src/index.jsx : import React from 'react' import ReactDOM from 'react-dom' import { Provider } from 'react-redux' import { createStore, applyMiddleware } from 'redux' import logger from 'redux-logger' import App from './App' import reducer from './reducer' const store = createStore(reducer, applyMiddleware(logger)) ReactDOM.render( <Provider store={store}> <App /> </Provider>, document.getElementById('root')) Set up a basic UI in src/App.jsx : import React from 'react' import { connect } from 'react-redux' const App = ({ fetchUser, user }) => ( <div> <button onClick={fetchUser}>Fetch User</button> <pre> { userData ? JSON.stringify(userData, null, 2) : 'no data fetched' } </pre> </div> ) const mapStateToProps = (state) => ({ user: state.user }) const mapDispatchToProps = (dispatch) => ({ fetchUser: () => dispatch({ type: 'FETCH_USER' }) }) export default connect( mapStateToProps, mapDispatchToProps )(App) Now on to actually using Redux Agent\u2026 The reducer and the task \u00b6 Our reducer has three goals: listen for the FETCH_USER action dispatched by the UI schedule an HTTP task listen for actions that signal the task success or failure Create src/reducer.js : import { addTask, reduceReducers, taskReducer } from 'redux-agent' const reducer = (state, action) => { switch(action.type) { case 'FETCH_USER': { return addTask(state, { type: 'http', method: 'get', url: 'https://jsonplaceholder.typicode.com/user/1', actions: { success: 'FETCH_USER_SUCCESS', failure: 'FETCH_USER_FAILURE' } }) } case 'FETCH_USER_SUCCESS': { return { ...state, userInfo: action.payload } } } } export default reduceReducers(reducer, taskReducer) Let\u2019s walk through the important bits: case 'FETCH_USER': { return addTask(state, { type: 'http', method: 'get', url: 'https://jsonplaceholder.typicode.com/user/1', actions: { success: 'FETCH_USER_SUCCESS', failure: 'FETCH_USER_FAILURE' } }) The addTask helper adds a task description to the application state. (Its sole purpose is to isolate you from the implementation of the task collection, in case it changes in future versions.) A task is a generic abstraction for an operation that we wish to be carried out. The task\u2019s type property determines which task handler will execute the task. Redux Agent currently ships with a few handlers, including HTTP, WebSocket, and timers, and it\u2019s easy to create more. A task may be short-lived, like the HTTP request above, or long-lived, like a timer or a WebSocket connection. A task execution leads to one or more events we\u2019ll want to hear about. For example, an HTTP task will produce just one \u2014 either a success or a failure event \u2014 wherease a WebSocket will produce several \u2014 typically one connect event, several message events, and finally a disconnect . Through the actions property, we tell Redux Agent what action should be dispatched when a certain event occurs. case 'FETCH_USER_SUCCESS': { return { ...state, userInfo: action.payload } } We handle the FETCH_USER_SUCCESS action by storing its payload (the parsed HTTP request body) into the state. export default reduceReducers(reducer, taskReducer) Finally, we want every action to flow not just through our application reducer but also through the task reducer. This ensures that the completed tasks are removed from the state. reduceReducers returns a reducer that consists of our application reducer plus the task reducer, concatenated. The runtime \u00b6 The runtime reads tasks from the state, executes them, and tells us what they did by dispatching actions. It does its job by observing the store and responding to state changes, like React does via react-redux \u2018s <Provider> component. To include the runtime and enable it handle HTTP tasks, add these two lines: import React from 'react' import ReactDOM from 'react-dom' import { Provider } from 'react-redux' import { createStore, applyMiddleware } from 'redux' + import { configureAgents, createHttpAgent } from 'redux-agent' import logger from 'redux-logger' import App from './App' import reducer from './reducer' const store = createStore(reducer, applyMiddleware(logger)) + store.subscribe(configureAgents([ createHttpAgent() ], store)) ReactDOM.render( <Provider store={store}> <App /> </Provider>, document.getElementById('root')) Done! \u00b6 That\u2019s it. Run yarn start , click the \u201cFetch User\u201d button, and the user info will appear. Next steps \u00b6 To view other task types in action, see the interactive examples . To learn more about built-in task types see the reference: HTTP , WebSocket , Storage , Timer , and Random Number Generator .","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"We\u2019ll make a simple \u201cwhen the user clicks this button, fetch a remote resource and display it\u201d application using Redux Agent and the HTTP task. We\u2019ll use a React app, but Redux Agent does not rely on React and works along any other UI runtime.","title":"Tutorial"},{"location":"tutorial/#a-skeleton-app","text":"Create a skeleton with create-react-app : $ yarn create react-app agent-tutorial Or: $ npx create-react-app agent-tutorial Install redux , redux-agent , react-redux , and redux-logger . $ cd agent-tutorial yarn add --dev redux react-redux redux-logger redux-agent Set up the entry point src/index.jsx : import React from 'react' import ReactDOM from 'react-dom' import { Provider } from 'react-redux' import { createStore, applyMiddleware } from 'redux' import logger from 'redux-logger' import App from './App' import reducer from './reducer' const store = createStore(reducer, applyMiddleware(logger)) ReactDOM.render( <Provider store={store}> <App /> </Provider>, document.getElementById('root')) Set up a basic UI in src/App.jsx : import React from 'react' import { connect } from 'react-redux' const App = ({ fetchUser, user }) => ( <div> <button onClick={fetchUser}>Fetch User</button> <pre> { userData ? JSON.stringify(userData, null, 2) : 'no data fetched' } </pre> </div> ) const mapStateToProps = (state) => ({ user: state.user }) const mapDispatchToProps = (dispatch) => ({ fetchUser: () => dispatch({ type: 'FETCH_USER' }) }) export default connect( mapStateToProps, mapDispatchToProps )(App) Now on to actually using Redux Agent\u2026","title":"A skeleton app"},{"location":"tutorial/#the-reducer-and-the-task","text":"Our reducer has three goals: listen for the FETCH_USER action dispatched by the UI schedule an HTTP task listen for actions that signal the task success or failure Create src/reducer.js : import { addTask, reduceReducers, taskReducer } from 'redux-agent' const reducer = (state, action) => { switch(action.type) { case 'FETCH_USER': { return addTask(state, { type: 'http', method: 'get', url: 'https://jsonplaceholder.typicode.com/user/1', actions: { success: 'FETCH_USER_SUCCESS', failure: 'FETCH_USER_FAILURE' } }) } case 'FETCH_USER_SUCCESS': { return { ...state, userInfo: action.payload } } } } export default reduceReducers(reducer, taskReducer) Let\u2019s walk through the important bits: case 'FETCH_USER': { return addTask(state, { type: 'http', method: 'get', url: 'https://jsonplaceholder.typicode.com/user/1', actions: { success: 'FETCH_USER_SUCCESS', failure: 'FETCH_USER_FAILURE' } }) The addTask helper adds a task description to the application state. (Its sole purpose is to isolate you from the implementation of the task collection, in case it changes in future versions.) A task is a generic abstraction for an operation that we wish to be carried out. The task\u2019s type property determines which task handler will execute the task. Redux Agent currently ships with a few handlers, including HTTP, WebSocket, and timers, and it\u2019s easy to create more. A task may be short-lived, like the HTTP request above, or long-lived, like a timer or a WebSocket connection. A task execution leads to one or more events we\u2019ll want to hear about. For example, an HTTP task will produce just one \u2014 either a success or a failure event \u2014 wherease a WebSocket will produce several \u2014 typically one connect event, several message events, and finally a disconnect . Through the actions property, we tell Redux Agent what action should be dispatched when a certain event occurs. case 'FETCH_USER_SUCCESS': { return { ...state, userInfo: action.payload } } We handle the FETCH_USER_SUCCESS action by storing its payload (the parsed HTTP request body) into the state. export default reduceReducers(reducer, taskReducer) Finally, we want every action to flow not just through our application reducer but also through the task reducer. This ensures that the completed tasks are removed from the state. reduceReducers returns a reducer that consists of our application reducer plus the task reducer, concatenated.","title":"The reducer and the task"},{"location":"tutorial/#the-runtime","text":"The runtime reads tasks from the state, executes them, and tells us what they did by dispatching actions. It does its job by observing the store and responding to state changes, like React does via react-redux \u2018s <Provider> component. To include the runtime and enable it handle HTTP tasks, add these two lines: import React from 'react' import ReactDOM from 'react-dom' import { Provider } from 'react-redux' import { createStore, applyMiddleware } from 'redux' + import { configureAgents, createHttpAgent } from 'redux-agent' import logger from 'redux-logger' import App from './App' import reducer from './reducer' const store = createStore(reducer, applyMiddleware(logger)) + store.subscribe(configureAgents([ createHttpAgent() ], store)) ReactDOM.render( <Provider store={store}> <App /> </Provider>, document.getElementById('root'))","title":"The runtime"},{"location":"tutorial/#done","text":"That\u2019s it. Run yarn start , click the \u201cFetch User\u201d button, and the user info will appear.","title":"Done!"},{"location":"tutorial/#next-steps","text":"To view other task types in action, see the interactive examples . To learn more about built-in task types see the reference: HTTP , WebSocket , Storage , Timer , and Random Number Generator .","title":"Next steps"},{"location":"guides/a-robust-reusable-login-flow-with-redux-agent-and-state-charts/","text":"Writing a robust, reusable login flow with redux\u2011agent and state charts \u00b6 Work in progress, 90% finished, missing sections point to the relevant parts of the repository for the project. Web application login is a complex puzzle: many possible error conditions, flows that stop on one page and resume on another (think email verification or OAuth), invitation codes, communication consent, \u2026 and all at a time when the user is least motivated to keep going if anything goes wrong. We\u2019ll see how to implement a login flow using redux-agent with some help from state charts. We want a result that is robust and understandable, and a process to achieve that through method, not effort. State charts aren\u2019t a requirement for using redux-agent, the two just happen to work beautifully together. Instead of the textbook username/password example, we\u2019ll make things more interesting by allowing the user to enter just an email and receive a one-time login link (what is sometimes called the \u201cmagic link\u201d auth strategy). This will make the flow more complex but will remove friction for the user (one less password to come up with) and work for back end engineers (no passwords to store). Thanks to redux-agent\u2019s model, we\u2019ll be able to place the logic in a self-contained reducer that: can be reused elsewhere with minimal modification shows clearly what state leads to which effects is independent of any particular UI framework Let\u2019s get started! The design \u00b6 In a perfect world, only this would happen: app loads user enters email and clicks \u201csend me a login link\u201d app tells user that email is on its way user opens inbox, finds email, and clicks on the link containing the token app loads again app verifies token app displays the main interface (home, dashboard, \u2026) Meanwhile, in the real world, the verification token may have expired and we should offer to resend the confirmation email; the server may be unreachable and we should notify the user; the user may be already logged in and we should show the main UI immediately\u2026 Here\u2019s a more realistic view of the possible flows, represented as a \u201cstate chart\u201d. In it, a box represents a state that the application may be in; I\u2019ll call it a control state to avoid confusion with Redux state . (To name such states, I like to ask \u201cWhat\u2019s the application doing at this point?\u201d) A label represents an input that the application will accept in a given state (a user action, a server response, \u2026). I won\u2019t go into details here about state charts, I\u2019ll just point out some of their benefits and encourage you to look more into them (pointers provided at the end): They make the implicit state machines your code already contains (in the form of isLoading , isError , etc.) explicit and thus easier to reason about They represent complex processes in a digestible form for both developers and designers They make it obvious when some case isn\u2019t covered They make implementation systematic and refreshingly boring With a little runtime support, they eliminate an entire class of bugs (the one caused by input coming in at invalid times such as double submits) The implementation \u00b6 The finished project is available on GitHub, clone it to follow along or play with it. It contains a basic React UI which we\u2019ll (mostly) not discuss in the article because redux-agent is independent of any particular UI framework. $ git clone https://github.com/bard/redux-agent-login-tutorial.git $ cd redux-agent-login-tutorial $ npm install $ npm start The state object \u00b6 { // A name that answers the question, \"What's the // application doing right now?\" // // E.g.: 'Starting', 'CheckingSession', 'CollectingInput', // 'SubmittingCredentials', ... controlState: 'Starting', // Some data specific to the 'Error' control state error: { // Error information, if any, to display to the user message: null, // State to go back to when the RETRY action is received retryState: null, // Optional task to re-run when retrying retryTask: null } } The reducer \u00b6 Let\u2019s start by enumerating the inputs (\u201cactions\u201d in Redux parlance) the system will respond to. These is essentially a copy/paste of the labels in the diagram we\u2019ve seen above: reducer.js : import { addTask } from 'redux-agent' // UI ACTIONS export const APP_LOADED = 'APP_LOADED' export const CREDENTIALS_ENTERED = 'CREDENTIALS_ENTERED' export const TOKEN_PROVIDED = 'TOKEN_PROVIDED' // NETWORK ACTIONS export const SESSION_SUCCESS = 'SESSION_SUCCESS' export const SESSION_FAILURE = 'SESSION_FAILURE' export const SUBMIT_CREDENTIALS_SUCCESS = 'SUBMIT_CREDENTIALS_SUCCESS' export const SUBMIT_CREDENTIALS_FAILURE = 'SUBMIT_CREDENTIALS_FAILURE' export const VERIFY_TOKEN_SUCCESS = 'VERIFY_TOKEN_SUCCESS' export const VERIFY_TOKEN_FAILURE = 'VERIFY_TOKEN_FAILURE' const reducer = (state, action) => { switch (action.type) { case APP_LOADED: { } case CREDENTIALS_ENTERED: { } case TOKEN_PROVIDED: { } case SESSION_SUCCESS: { } // ... and so on ... default: return state } } export default reducer Checking if a session exists \u00b6 At the beginning, when the application is loading, we expect to receive an APP_LOADED action. How that action is dispatched is up to you and your UI framework of choice. In the React-based example app it is: App.jsx : import React, { useEffect } from 'react' import { useDispatch } from 'react-redux' import { APP_LOADED } from './reducers/login' const App = () => { const dispatch = useDispatch() const dispatch = useDispatch() // Passing an empty dependency array to only run effect at mount time useEffect(() => { dispatch({ type: APP_LOADED }) }, []) return (<div>...</div>) } export default App Once the application has loaded, we want to check if we have a session already, because if we do, we can skip the login flow entirely. We\u2019ll do that by querying the (mocked) REST API for a resource that is only available to logged-in users, e.g. /account : case APP_LOADED: { return addTask(state, { type: 'http', method: 'get', url: '/account', actions: { success: SESSION_SUCCESS, failure: SESSION_FAILURE } }) } We can make that easier on the eyes by taking a page out of Redux conventions and encapsulating the task in a task creator, as we would do with actions and action creators: const checkSession = () => ({ type: 'http', method: 'get', url: '/account', actions: { success: SESSION_SUCCESS, failure: SESSION_FAILURE } }) const reducer = (state, action) => { switch(action.type) { case APP_LOADED: { return addTask(state, checkSession()) } We\u2019ll also keep track of what control state we\u2019re in, for two purposes: we can use that information in the UI (e.g. show a loader, change screen, disable input) we can make sure that we don\u2019t handle actions out of their intended context (such as when a user clicks a form \u201csubmit\u201d button a second time) Tracking the control state is trivial: case APP_LOADED: { - return addTask(state, checkSession()) + const newState = addTask(state, checkSession()) + + return { ...newState, controlState: 'CheckingSession' } } And to handle APP_LOADED only if we\u2019re in the Starting control state: case APP_LOADED: { + if (state.controlState !== 'Starting') return state + const newState = addTask(state, checkSession()) What we end up with: case APP_LOADED: { if (state.controlState !== 'Starting') return state const newState = addTask(state, checkSession()) return { ...newState, controlState: 'CheckingSession' } } Next we\u2019ll handle the possible outcomes of the GET /account HTTP task: success (we have a session) or failure (we either don\u2019t have a session or can\u2019t find out due to network or server error). In case of success, we just want to display the main UI, so we set the appropriate control state and let react-redux or equivalent bring up the correct UI: case SESSION_SUCCESS: { if (state.controlState !== 'CheckingSession') return state return { ...state, controlState: 'Home' } } The failure case needs a little more attention. If the HTTP request failed with a 401 code, then we know we\u2019re not authenticated and must show the login form. If it failed with any other error, we want to display the error and give the user a chance of retrying. (Note that the action payload carries the response body and the action meta carries the response status code.) case SESSION_FAILURE: { if (state.controlState !== 'CheckingSession') return state if (action.meta.status === 401) { return { ...state, controlState: 'CollectingInput' } } else { return { ...state, controlState: 'Error', error: { message: action.payload, retryState: 'CheckingSession', retryTask: checkSession() } } } } Our reducer so far: const reducer = (state, action) => { switch (action.type) { case APP_LOADED: { if (state.controlState !== 'Starting') return state const newState = addTask(state, checkSession()) return { ...newState, controlState: 'CheckingSession' } } case SESSION_SUCCESS: { if (state.controlState !== 'CheckingSession') return state return { ...state, controlState: 'Home' } } case SESSION_FAILURE: { if (state.controlState !== 'CheckingSession') return state if (action.meta.status === 401) { return { ...state, controlState: 'CollectingInput' } } else { return { ...state, controlState: 'Error', error: { message: action.payload, retryState: 'CheckingSession', retryTask: checkSession() } } } } } } Collecting input \u00b6 If no session is present and we find ourselves in the CollectingInput state, it may be because the user accessed the app for the first time, or it may be because the user clicked on an email verification link resulting from a previous login attempt, thus in the CollectingInput state the UI will need to do two things: display the login form check the location bar for an email verification token If the token is there, the UI will dispatch a TOKEN_PROVIDED action; if not, it will wait for user input and then dispatch a CREDENTIALS_ENTERED action. (See the example app for a way of doing that with React.) Both actions imply an HTTP task, either to submit the request for a login link, or to verify the token. Submitting the request for a login link: const submitCredentials = (email) => ({ type: 'http', method: 'post', url: '/auth/email/requests', body: { email }, actions: { success: SUBMIT_CREDENTIALS_SUCCESS, failure: SUBMIT_CREDENTIALS_FAILURE, } }) const reducer = (state, action) => { switch (action.type) { case CREDENTIALS_ENTERED: { if (state.controlState !== 'CollectingInput') return state const { email } = action.payload const newState = addTask(state, submitCredentials(email)) return { ...newState, controlState: 'SubmittingCredentials' } } Verifying the token: const verifyToken = (token) => ({ type: 'http', method: 'post', url: '/auth/email/verifications', body: { token }, actions: { success: VERIFY_TOKEN_SUCCESS, failure: VERIFY_TOKEN_FAILURE, } }) const reducer = (state, action) => { switch (action.type) { case TOKEN_PROVIDED: { if (state.controlState !== 'CollectingInput') return state const { token } = action.payload const newState = addTask(state, verifyToken(token)) return { ...newState, controlState: 'VerifyingToken' } } Notice a pattern? \u00b6 You\u2019ve probably noticed that each action handler going through similar steps: // Encapsulate task creation const taskCreator = (taskParams) => ({ ... }) const reducer = (state, action) => { switch (action.type) { case ACTION: { // Ignore action if invalid in the current control state if (state.controlState !== 'StateWhereActionIsValid') return state // If the flow requires a new task other than user input, initiate it const newState = addTask(state, taskCreator(taskParams)) // Assign the appropriate control state and return return { ...newState, controlState: 'SomeNextState' } } Most of the action handlers left to write follow the same pattern, so I\u2019ll refer you to the reducer in the repository instead of repeating the pattern again. One part however deserves some additional attention, and that is\u2026 The Error control state and the RETRY action \u00b6 TODO. See the repo . To test for error states, modify the server response in src/mocks.js , for example from: fetchMock.post('/auth/email/verifications', async () => { await simulateNetworkDelay() return { status: 200 } }) To: fetchMock.post('/auth/email/verifications', async () => { await simulateNetworkDelay() return { status: 400, { body: 'No such code' }} }) Integrating the reducer \u00b6 TODO . See the repo . Notes \u00b6 This is just one, and far from complete, way of implementing state charts with Redux. It can be improved in many ways which are not included here for brevity: The check at the beginning of each handler may be converted to a more expressive assertControlState(state, 'CollectingInput') . See this gist [TODO]. Since control states are closely associated with tasks, we could host both in the same function and call it with e.g. return CredentialsEntered(state) . This would be a way of implementing entry actions . As the application grows, it\u2019s necessary to tell states of different flows apart. Starting would stay the same, but CheckingSession and CollectingInput may become Auth:CheckingSession and Auth:CollectingInput , and be joined by Settings:CollectingInput , Settings:SubmittingUpdates , Main:BrowsingPosts , Main:WritingPost , \u2026 Further reading about redux-agent \u00b6 Tutorial - Building a simple application to demonstrate usage of the HTTP task and general setup for using redux-agent HTTP Task Refererence Further reading about state charts \u00b6 Welcome to the world of Statecharts \u2014 An introduction to state charts Sketch.systems \u2014 Design state charts in the browser using simple markup and test the flows interactively Robust Engineering: User Interfaces You Can Trust with State Machines \u2014 Not strictly about state charts but good rationale for using explicit state machines in UI design","title":"(draft) Writing a robust, reusable login flow with redux\u2011agent and state charts"},{"location":"guides/a-robust-reusable-login-flow-with-redux-agent-and-state-charts/#writing-a-robust-reusable-login-flow-with-reduxagent-and-state-charts","text":"Work in progress, 90% finished, missing sections point to the relevant parts of the repository for the project. Web application login is a complex puzzle: many possible error conditions, flows that stop on one page and resume on another (think email verification or OAuth), invitation codes, communication consent, \u2026 and all at a time when the user is least motivated to keep going if anything goes wrong. We\u2019ll see how to implement a login flow using redux-agent with some help from state charts. We want a result that is robust and understandable, and a process to achieve that through method, not effort. State charts aren\u2019t a requirement for using redux-agent, the two just happen to work beautifully together. Instead of the textbook username/password example, we\u2019ll make things more interesting by allowing the user to enter just an email and receive a one-time login link (what is sometimes called the \u201cmagic link\u201d auth strategy). This will make the flow more complex but will remove friction for the user (one less password to come up with) and work for back end engineers (no passwords to store). Thanks to redux-agent\u2019s model, we\u2019ll be able to place the logic in a self-contained reducer that: can be reused elsewhere with minimal modification shows clearly what state leads to which effects is independent of any particular UI framework Let\u2019s get started!","title":"Writing a robust, reusable login flow with redux\u2011agent and state charts"},{"location":"guides/a-robust-reusable-login-flow-with-redux-agent-and-state-charts/#the-design","text":"In a perfect world, only this would happen: app loads user enters email and clicks \u201csend me a login link\u201d app tells user that email is on its way user opens inbox, finds email, and clicks on the link containing the token app loads again app verifies token app displays the main interface (home, dashboard, \u2026) Meanwhile, in the real world, the verification token may have expired and we should offer to resend the confirmation email; the server may be unreachable and we should notify the user; the user may be already logged in and we should show the main UI immediately\u2026 Here\u2019s a more realistic view of the possible flows, represented as a \u201cstate chart\u201d. In it, a box represents a state that the application may be in; I\u2019ll call it a control state to avoid confusion with Redux state . (To name such states, I like to ask \u201cWhat\u2019s the application doing at this point?\u201d) A label represents an input that the application will accept in a given state (a user action, a server response, \u2026). I won\u2019t go into details here about state charts, I\u2019ll just point out some of their benefits and encourage you to look more into them (pointers provided at the end): They make the implicit state machines your code already contains (in the form of isLoading , isError , etc.) explicit and thus easier to reason about They represent complex processes in a digestible form for both developers and designers They make it obvious when some case isn\u2019t covered They make implementation systematic and refreshingly boring With a little runtime support, they eliminate an entire class of bugs (the one caused by input coming in at invalid times such as double submits)","title":"The design"},{"location":"guides/a-robust-reusable-login-flow-with-redux-agent-and-state-charts/#the-implementation","text":"The finished project is available on GitHub, clone it to follow along or play with it. It contains a basic React UI which we\u2019ll (mostly) not discuss in the article because redux-agent is independent of any particular UI framework. $ git clone https://github.com/bard/redux-agent-login-tutorial.git $ cd redux-agent-login-tutorial $ npm install $ npm start","title":"The implementation"},{"location":"guides/a-robust-reusable-login-flow-with-redux-agent-and-state-charts/#the-state-object","text":"{ // A name that answers the question, \"What's the // application doing right now?\" // // E.g.: 'Starting', 'CheckingSession', 'CollectingInput', // 'SubmittingCredentials', ... controlState: 'Starting', // Some data specific to the 'Error' control state error: { // Error information, if any, to display to the user message: null, // State to go back to when the RETRY action is received retryState: null, // Optional task to re-run when retrying retryTask: null } }","title":"The state object"},{"location":"guides/a-robust-reusable-login-flow-with-redux-agent-and-state-charts/#the-reducer","text":"Let\u2019s start by enumerating the inputs (\u201cactions\u201d in Redux parlance) the system will respond to. These is essentially a copy/paste of the labels in the diagram we\u2019ve seen above: reducer.js : import { addTask } from 'redux-agent' // UI ACTIONS export const APP_LOADED = 'APP_LOADED' export const CREDENTIALS_ENTERED = 'CREDENTIALS_ENTERED' export const TOKEN_PROVIDED = 'TOKEN_PROVIDED' // NETWORK ACTIONS export const SESSION_SUCCESS = 'SESSION_SUCCESS' export const SESSION_FAILURE = 'SESSION_FAILURE' export const SUBMIT_CREDENTIALS_SUCCESS = 'SUBMIT_CREDENTIALS_SUCCESS' export const SUBMIT_CREDENTIALS_FAILURE = 'SUBMIT_CREDENTIALS_FAILURE' export const VERIFY_TOKEN_SUCCESS = 'VERIFY_TOKEN_SUCCESS' export const VERIFY_TOKEN_FAILURE = 'VERIFY_TOKEN_FAILURE' const reducer = (state, action) => { switch (action.type) { case APP_LOADED: { } case CREDENTIALS_ENTERED: { } case TOKEN_PROVIDED: { } case SESSION_SUCCESS: { } // ... and so on ... default: return state } } export default reducer","title":"The reducer"},{"location":"guides/a-robust-reusable-login-flow-with-redux-agent-and-state-charts/#checking-if-a-session-exists","text":"At the beginning, when the application is loading, we expect to receive an APP_LOADED action. How that action is dispatched is up to you and your UI framework of choice. In the React-based example app it is: App.jsx : import React, { useEffect } from 'react' import { useDispatch } from 'react-redux' import { APP_LOADED } from './reducers/login' const App = () => { const dispatch = useDispatch() const dispatch = useDispatch() // Passing an empty dependency array to only run effect at mount time useEffect(() => { dispatch({ type: APP_LOADED }) }, []) return (<div>...</div>) } export default App Once the application has loaded, we want to check if we have a session already, because if we do, we can skip the login flow entirely. We\u2019ll do that by querying the (mocked) REST API for a resource that is only available to logged-in users, e.g. /account : case APP_LOADED: { return addTask(state, { type: 'http', method: 'get', url: '/account', actions: { success: SESSION_SUCCESS, failure: SESSION_FAILURE } }) } We can make that easier on the eyes by taking a page out of Redux conventions and encapsulating the task in a task creator, as we would do with actions and action creators: const checkSession = () => ({ type: 'http', method: 'get', url: '/account', actions: { success: SESSION_SUCCESS, failure: SESSION_FAILURE } }) const reducer = (state, action) => { switch(action.type) { case APP_LOADED: { return addTask(state, checkSession()) } We\u2019ll also keep track of what control state we\u2019re in, for two purposes: we can use that information in the UI (e.g. show a loader, change screen, disable input) we can make sure that we don\u2019t handle actions out of their intended context (such as when a user clicks a form \u201csubmit\u201d button a second time) Tracking the control state is trivial: case APP_LOADED: { - return addTask(state, checkSession()) + const newState = addTask(state, checkSession()) + + return { ...newState, controlState: 'CheckingSession' } } And to handle APP_LOADED only if we\u2019re in the Starting control state: case APP_LOADED: { + if (state.controlState !== 'Starting') return state + const newState = addTask(state, checkSession()) What we end up with: case APP_LOADED: { if (state.controlState !== 'Starting') return state const newState = addTask(state, checkSession()) return { ...newState, controlState: 'CheckingSession' } } Next we\u2019ll handle the possible outcomes of the GET /account HTTP task: success (we have a session) or failure (we either don\u2019t have a session or can\u2019t find out due to network or server error). In case of success, we just want to display the main UI, so we set the appropriate control state and let react-redux or equivalent bring up the correct UI: case SESSION_SUCCESS: { if (state.controlState !== 'CheckingSession') return state return { ...state, controlState: 'Home' } } The failure case needs a little more attention. If the HTTP request failed with a 401 code, then we know we\u2019re not authenticated and must show the login form. If it failed with any other error, we want to display the error and give the user a chance of retrying. (Note that the action payload carries the response body and the action meta carries the response status code.) case SESSION_FAILURE: { if (state.controlState !== 'CheckingSession') return state if (action.meta.status === 401) { return { ...state, controlState: 'CollectingInput' } } else { return { ...state, controlState: 'Error', error: { message: action.payload, retryState: 'CheckingSession', retryTask: checkSession() } } } } Our reducer so far: const reducer = (state, action) => { switch (action.type) { case APP_LOADED: { if (state.controlState !== 'Starting') return state const newState = addTask(state, checkSession()) return { ...newState, controlState: 'CheckingSession' } } case SESSION_SUCCESS: { if (state.controlState !== 'CheckingSession') return state return { ...state, controlState: 'Home' } } case SESSION_FAILURE: { if (state.controlState !== 'CheckingSession') return state if (action.meta.status === 401) { return { ...state, controlState: 'CollectingInput' } } else { return { ...state, controlState: 'Error', error: { message: action.payload, retryState: 'CheckingSession', retryTask: checkSession() } } } } } }","title":"Checking if a session exists"},{"location":"guides/a-robust-reusable-login-flow-with-redux-agent-and-state-charts/#collecting-input","text":"If no session is present and we find ourselves in the CollectingInput state, it may be because the user accessed the app for the first time, or it may be because the user clicked on an email verification link resulting from a previous login attempt, thus in the CollectingInput state the UI will need to do two things: display the login form check the location bar for an email verification token If the token is there, the UI will dispatch a TOKEN_PROVIDED action; if not, it will wait for user input and then dispatch a CREDENTIALS_ENTERED action. (See the example app for a way of doing that with React.) Both actions imply an HTTP task, either to submit the request for a login link, or to verify the token. Submitting the request for a login link: const submitCredentials = (email) => ({ type: 'http', method: 'post', url: '/auth/email/requests', body: { email }, actions: { success: SUBMIT_CREDENTIALS_SUCCESS, failure: SUBMIT_CREDENTIALS_FAILURE, } }) const reducer = (state, action) => { switch (action.type) { case CREDENTIALS_ENTERED: { if (state.controlState !== 'CollectingInput') return state const { email } = action.payload const newState = addTask(state, submitCredentials(email)) return { ...newState, controlState: 'SubmittingCredentials' } } Verifying the token: const verifyToken = (token) => ({ type: 'http', method: 'post', url: '/auth/email/verifications', body: { token }, actions: { success: VERIFY_TOKEN_SUCCESS, failure: VERIFY_TOKEN_FAILURE, } }) const reducer = (state, action) => { switch (action.type) { case TOKEN_PROVIDED: { if (state.controlState !== 'CollectingInput') return state const { token } = action.payload const newState = addTask(state, verifyToken(token)) return { ...newState, controlState: 'VerifyingToken' } }","title":"Collecting input"},{"location":"guides/a-robust-reusable-login-flow-with-redux-agent-and-state-charts/#notice-a-pattern","text":"You\u2019ve probably noticed that each action handler going through similar steps: // Encapsulate task creation const taskCreator = (taskParams) => ({ ... }) const reducer = (state, action) => { switch (action.type) { case ACTION: { // Ignore action if invalid in the current control state if (state.controlState !== 'StateWhereActionIsValid') return state // If the flow requires a new task other than user input, initiate it const newState = addTask(state, taskCreator(taskParams)) // Assign the appropriate control state and return return { ...newState, controlState: 'SomeNextState' } } Most of the action handlers left to write follow the same pattern, so I\u2019ll refer you to the reducer in the repository instead of repeating the pattern again. One part however deserves some additional attention, and that is\u2026","title":"Notice a pattern?"},{"location":"guides/a-robust-reusable-login-flow-with-redux-agent-and-state-charts/#the-error-control-state-and-the-retry-action","text":"TODO. See the repo . To test for error states, modify the server response in src/mocks.js , for example from: fetchMock.post('/auth/email/verifications', async () => { await simulateNetworkDelay() return { status: 200 } }) To: fetchMock.post('/auth/email/verifications', async () => { await simulateNetworkDelay() return { status: 400, { body: 'No such code' }} })","title":"The Error control state and the RETRY action"},{"location":"guides/a-robust-reusable-login-flow-with-redux-agent-and-state-charts/#integrating-the-reducer","text":"TODO . See the repo .","title":"Integrating the reducer"},{"location":"guides/a-robust-reusable-login-flow-with-redux-agent-and-state-charts/#notes","text":"This is just one, and far from complete, way of implementing state charts with Redux. It can be improved in many ways which are not included here for brevity: The check at the beginning of each handler may be converted to a more expressive assertControlState(state, 'CollectingInput') . See this gist [TODO]. Since control states are closely associated with tasks, we could host both in the same function and call it with e.g. return CredentialsEntered(state) . This would be a way of implementing entry actions . As the application grows, it\u2019s necessary to tell states of different flows apart. Starting would stay the same, but CheckingSession and CollectingInput may become Auth:CheckingSession and Auth:CollectingInput , and be joined by Settings:CollectingInput , Settings:SubmittingUpdates , Main:BrowsingPosts , Main:WritingPost , \u2026","title":"Notes"},{"location":"guides/a-robust-reusable-login-flow-with-redux-agent-and-state-charts/#further-reading-about-redux-agent","text":"Tutorial - Building a simple application to demonstrate usage of the HTTP task and general setup for using redux-agent HTTP Task Refererence","title":"Further reading about redux-agent"},{"location":"guides/a-robust-reusable-login-flow-with-redux-agent-and-state-charts/#further-reading-about-state-charts","text":"Welcome to the world of Statecharts \u2014 An introduction to state charts Sketch.systems \u2014 Design state charts in the browser using simple markup and test the flows interactively Robust Engineering: User Interfaces You Can Trust with State Machines \u2014 Not strictly about state charts but good rationale for using explicit state machines in UI design","title":"Further reading about state charts"},{"location":"guides/immer-support/","text":"Immer is a discover-it-then-cant-live-without-it library that lets you create immutable objects using an imperative-looking API, greatly enhancing readability. For example, the following: switch (action.type) { case 'USER_RENAME': return { ...state, user: { ...state.user, name: action.payload } } } \u2026using Immer becomes: switch (action.type) { case 'USER_RENAME': draft.user.name = action.payload return } Redux Agent\u2019s addTask and delTasks helpers have built-in support for Immer: pass them an Immer draft and you can use them imperatively. This: import { addTask } from 'redux-agent' const getTodo = (id) => ({ /* ... */ }) const reducer = (state, action) => { switch(action.type) { case 'FETCH_USER': return addTask( { ...state, isLoading: true }, getTodo(1) ) \u2026using Immer becomes: import { produce } from 'immer' import { addTask } from 'redux-agent' const getTodo = (id) => ({ /* ... */ }) const reducer = (state, action) => produce(state, (draft) => { switch(action.type) { case 'FETCH_USER': addTask(draft, getTodo(1)) draft.isLoading = true return Read more about Immer in Introducing Immer: Immutability the easy way and on its project page .","title":"Immer Support"},{"location":"reference/http/","text":"The HTTP task handler allows to perform HTTP requests using window.fetch . Configuration \u00b6 Parameter Type Description baseUrl string Optional. Prepended to all request URLs, defaults to empty string. fetchDefaults object Optional. Included in all window.fetch calls, defaults to empty. Example: import { configureAgents, createHttpAgent } from 'redux-agent' store.subscribe(configureAgents([ createHttpAgent({ // cause requests to /foo/bar to be sent to /api/v1/foo/bar baseUrl: '/api/v1', // allow authenticated CORS fetchDefaults: { credentials: 'include' } }) ], store)) Task: Default \u00b6 This task describes an HTTP request and the actions to dispatch based on its completion. { type: 'http', url: string, // URL to request method: string, // HTTP method body: any, // optional, data for POST/PUT/PATCH actions: { success: string, // action type to dispatch when request succeeds failure: string // action type to dispatch when request fails }, ...rest // any other parameters are forwarded to window.fetch } Note If data is an object, it will be encoded to JSON and the content-type header will be set accordingly. Note Responses are considered successful when the status code is in the 2xx range. Responses are considered failed when the status code is in the 4xx and 5xx range or when the request could not be sent (e.g. due to a network problem). This is in contrast with the fetch spec where 4xx and 5xx responses are also considered successful. Actions \u00b6 Event Type Meta Payload success { status: number } The response body. Automatically decoded to object if json, otherwise string failure { status: number } The response body. Automatically decoded to object if json, otherwise string Example \u00b6 Run this example \u00bb import { addTask, reduceReducers, taskReducer } from 'redux-agent' const reducer = (state, action) => { switch (action.type) { case 'FETCH_TODO': return addTask(state, { type: 'http', method: 'get', url: 'https://jsonplaceholder.typicode.com/todos/1', actions: { success: 'FETCH_TODO_SUCCESS', failure: 'FETCH_TODO_FAILURE' } }) case 'FETCH_TODO_SUCCESS': return { ...state, httpTodoItem: action.payload } default: return state } } export default reduceReducers(reducer, taskReducer)","title":"HTTP"},{"location":"reference/http/#configuration","text":"Parameter Type Description baseUrl string Optional. Prepended to all request URLs, defaults to empty string. fetchDefaults object Optional. Included in all window.fetch calls, defaults to empty. Example: import { configureAgents, createHttpAgent } from 'redux-agent' store.subscribe(configureAgents([ createHttpAgent({ // cause requests to /foo/bar to be sent to /api/v1/foo/bar baseUrl: '/api/v1', // allow authenticated CORS fetchDefaults: { credentials: 'include' } }) ], store))","title":"Configuration"},{"location":"reference/http/#task-default","text":"This task describes an HTTP request and the actions to dispatch based on its completion. { type: 'http', url: string, // URL to request method: string, // HTTP method body: any, // optional, data for POST/PUT/PATCH actions: { success: string, // action type to dispatch when request succeeds failure: string // action type to dispatch when request fails }, ...rest // any other parameters are forwarded to window.fetch } Note If data is an object, it will be encoded to JSON and the content-type header will be set accordingly. Note Responses are considered successful when the status code is in the 2xx range. Responses are considered failed when the status code is in the 4xx and 5xx range or when the request could not be sent (e.g. due to a network problem). This is in contrast with the fetch spec where 4xx and 5xx responses are also considered successful.","title":"Task: Default"},{"location":"reference/http/#actions","text":"Event Type Meta Payload success { status: number } The response body. Automatically decoded to object if json, otherwise string failure { status: number } The response body. Automatically decoded to object if json, otherwise string","title":"Actions"},{"location":"reference/http/#example","text":"Run this example \u00bb import { addTask, reduceReducers, taskReducer } from 'redux-agent' const reducer = (state, action) => { switch (action.type) { case 'FETCH_TODO': return addTask(state, { type: 'http', method: 'get', url: 'https://jsonplaceholder.typicode.com/todos/1', actions: { success: 'FETCH_TODO_SUCCESS', failure: 'FETCH_TODO_FAILURE' } }) case 'FETCH_TODO_SUCCESS': return { ...state, httpTodoItem: action.payload } default: return state } } export default reduceReducers(reducer, taskReducer)","title":"Example"},{"location":"reference/random-number-generator/","text":"Random Number Generator \u00b6 The RNG task handler allows generating random numbers outside of the reducer, so as not to make the reducer impure. Task: Default \u00b6 This task causes a random number to be generated and to be dispatched back to as payload of the prescribe action. { type: 'rng', actions: { result: string // action type to dispatch when the number has been generated } } Actions \u00b6 Event Type Meta Payload result none number Example \u00b6 Run this example \u00bb import { addTask, reduceReducers, taskReducer } from 'redux-agent' const reducer = (state, action) => { switch (action.type) { case 'RANDOM_NUMBER': return addTask(state, { type: 'rng', actions: { result: 'RANDOM_NUMBER_RESULT' } }) case 'RANDOM_NUMBER_RESULT': return { ...state, randomNumber: action.payload } default: return state } } export default reduceReducers(reducer, taskReducer)","title":"RNG"},{"location":"reference/random-number-generator/#random-number-generator","text":"The RNG task handler allows generating random numbers outside of the reducer, so as not to make the reducer impure.","title":"Random Number Generator"},{"location":"reference/random-number-generator/#task-default","text":"This task causes a random number to be generated and to be dispatched back to as payload of the prescribe action. { type: 'rng', actions: { result: string // action type to dispatch when the number has been generated } }","title":"Task: Default"},{"location":"reference/random-number-generator/#actions","text":"Event Type Meta Payload result none number","title":"Actions"},{"location":"reference/random-number-generator/#example","text":"Run this example \u00bb import { addTask, reduceReducers, taskReducer } from 'redux-agent' const reducer = (state, action) => { switch (action.type) { case 'RANDOM_NUMBER': return addTask(state, { type: 'rng', actions: { result: 'RANDOM_NUMBER_RESULT' } }) case 'RANDOM_NUMBER_RESULT': return { ...state, randomNumber: action.payload } default: return state } } export default reduceReducers(reducer, taskReducer)","title":"Example"},{"location":"reference/storage/","text":"The storage task handler allows reading from and writing to the DOM localStorage object. It provides basic get, set, and delete operations, plus convenience operations such as pop (atomic get plus delete) or merge (atomic get plus shallow merge). Data is encoded as JSON before writing and decoded before reading. Task: Set \u00b6 Write a value to local storage. { type: 'storage', op: 'set', key: string, // key to look up data with data: any, // JSON-encodable value (object, string, boolean, etc.) actions: { success: string, // action type to dispatch when data has been read failure: string // action type to dispatch when data could not be read } } Actions \u00b6 Event Type Description Meta Payload success Dispatched when data has been written { key: string } None failure Dispatched when data could not be written { key: string } None Task: Get \u00b6 Read a value from local storage. interface LocalStorageGetTask { type: 'storage', op: 'get', key: string, // key of the value to read actions: { success: string, // action type to dispatch when data has been read failure: string // action type to dispatch when data could not be read } } Actions \u00b6 Event Type Description Meta Payload success Dispatched when data has been read { key: string } The requested data failure Dispatched when data could not be read { key: string } None Task: Del \u00b6 Delete a value from local storage. interface LocalStorageDelTask { type: 'storage', op: 'del', key: string, // key of the value to be deleted actions: { success: string, // action type to dispatch when data has been read failure: string // action type to dispatch when data could not be read } } Name Type Description type string Must be 'storage' op string Must be 'del' key string Key of the data item actions object Actions to dispatch depending on task execution, in the form { [eventType]: actionName } . See below for available actions Actions \u00b6 Event Type Description Meta Payload success Dispatched when data has been deleted { key: string } None failure Dispatched when the data could not be deleted { key: string } None Task: Pop \u00b6 Read and remove a value data from local storage in one go. interface LocalStoragePopTask { type: 'storage', op: 'pop', key: string, // key of the valued to be read actions: { success: string, // action type to dispatch when data has been read failure: string // action type to dispatch when data could not be read } } Actions \u00b6 Event Type Meta Payload success { key: string } The requested data, JSON-decoded failure { key: string } None Task: Merge \u00b6 Update a stored value by shallow-merging new data with it. interface LocalStorageSetTask { type: 'storage', op: 'set', key: string, // key of the value to be updated data: object, // data to shallow-merge with the existing value actions: { success: string, // action type to dispatch when data has been read failure: string // action type to dispatch when data could not be read } } Actions \u00b6 Event Type Description Meta Payload success Dispatched when data has been merged { key: string } None failure Dispatched when data could not be merged { key: string } None","title":"Storage"},{"location":"reference/storage/#task-set","text":"Write a value to local storage. { type: 'storage', op: 'set', key: string, // key to look up data with data: any, // JSON-encodable value (object, string, boolean, etc.) actions: { success: string, // action type to dispatch when data has been read failure: string // action type to dispatch when data could not be read } }","title":"Task: Set"},{"location":"reference/storage/#actions","text":"Event Type Description Meta Payload success Dispatched when data has been written { key: string } None failure Dispatched when data could not be written { key: string } None","title":"Actions"},{"location":"reference/storage/#task-get","text":"Read a value from local storage. interface LocalStorageGetTask { type: 'storage', op: 'get', key: string, // key of the value to read actions: { success: string, // action type to dispatch when data has been read failure: string // action type to dispatch when data could not be read } }","title":"Task: Get"},{"location":"reference/storage/#actions_1","text":"Event Type Description Meta Payload success Dispatched when data has been read { key: string } The requested data failure Dispatched when data could not be read { key: string } None","title":"Actions"},{"location":"reference/storage/#task-del","text":"Delete a value from local storage. interface LocalStorageDelTask { type: 'storage', op: 'del', key: string, // key of the value to be deleted actions: { success: string, // action type to dispatch when data has been read failure: string // action type to dispatch when data could not be read } } Name Type Description type string Must be 'storage' op string Must be 'del' key string Key of the data item actions object Actions to dispatch depending on task execution, in the form { [eventType]: actionName } . See below for available actions","title":"Task: Del"},{"location":"reference/storage/#actions_2","text":"Event Type Description Meta Payload success Dispatched when data has been deleted { key: string } None failure Dispatched when the data could not be deleted { key: string } None","title":"Actions"},{"location":"reference/storage/#task-pop","text":"Read and remove a value data from local storage in one go. interface LocalStoragePopTask { type: 'storage', op: 'pop', key: string, // key of the valued to be read actions: { success: string, // action type to dispatch when data has been read failure: string // action type to dispatch when data could not be read } }","title":"Task: Pop"},{"location":"reference/storage/#actions_3","text":"Event Type Meta Payload success { key: string } The requested data, JSON-decoded failure { key: string } None","title":"Actions"},{"location":"reference/storage/#task-merge","text":"Update a stored value by shallow-merging new data with it. interface LocalStorageSetTask { type: 'storage', op: 'set', key: string, // key of the value to be updated data: object, // data to shallow-merge with the existing value actions: { success: string, // action type to dispatch when data has been read failure: string // action type to dispatch when data could not be read } }","title":"Task: Merge"},{"location":"reference/storage/#actions_4","text":"Event Type Description Meta Payload success Dispatched when data has been merged { key: string } None failure Dispatched when data could not be merged { key: string } None","title":"Actions"},{"location":"reference/timer/","text":"The timer task handler allows creating simple timers. Task: Default \u00b6 This task describes a timer and the action that should be dispatched at the specified interval. { type: 'timer', interval: number, // time in ms at which the tick action should be dispatched actions: { tick: string // action type to dispatch when the number has been generated } } Tip To stop a timer, simply remove the task (see how in the example ). Actions \u00b6 Event Type Meta Payload tick None None Example \u00b6 Run this example \u00bb import { addTask, delTasks, reduceReducers, taskReducer } from 'redux-agent' const reducer = (state, action) => { switch (action.type) { case 'START_TIMER': return addTask(state, { type: 'timer', interval: 500, actions: { tick: 'TICK' } }) case 'TICK': return { ...state, counter: state.counter + 1 } case 'STOP_ALL_TIMERS': return delTasks(state, (t) => t.type === 'timer') default: return state } } export default reduceReducers(reducer, taskReducer)","title":"Timer"},{"location":"reference/timer/#task-default","text":"This task describes a timer and the action that should be dispatched at the specified interval. { type: 'timer', interval: number, // time in ms at which the tick action should be dispatched actions: { tick: string // action type to dispatch when the number has been generated } } Tip To stop a timer, simply remove the task (see how in the example ).","title":"Task: Default"},{"location":"reference/timer/#actions","text":"Event Type Meta Payload tick None None","title":"Actions"},{"location":"reference/timer/#example","text":"Run this example \u00bb import { addTask, delTasks, reduceReducers, taskReducer } from 'redux-agent' const reducer = (state, action) => { switch (action.type) { case 'START_TIMER': return addTask(state, { type: 'timer', interval: 500, actions: { tick: 'TICK' } }) case 'TICK': return { ...state, counter: state.counter + 1 } case 'STOP_ALL_TIMERS': return delTasks(state, (t) => t.type === 'timer') default: return state } } export default reduceReducers(reducer, taskReducer)","title":"Example"},{"location":"reference/websocket/","text":"The WebSocket task handler allows to create a WebSocket connection, send messages, and listen on incoming ones. Configuration \u00b6 Parameter Type Description socketFactory (connectionUrl: string) => WebSocketLike Optional. Function that will be used to create the socket, useful to provide compatibility layers (e.g. Primus, SockJS) or enhanced versions of WebSocket. Defaults to creating a standard WebSocket encode (data: any) => any Optional. Function to encode data from a send task into a wire format. Defaults to JSON.stringify decode (data: any) => any Optional. Function to decode data from the wire into a format useful for application code. Defaults to JSON.parse Example: import ReconnectingWebSocket from 'reconnecting-websocket' import { configureAgents, createSocketAgent } from 'redux-agent' store.subscribe(configureAgents([ createSocketAgent({ // Provide enhanced/wrapped implementation socketFactory: (url) => new ReconnectingWebSocket(url) // skip JSON encoding encode: (data) => data, // skip JSON decoding decode: (data) => data }) ], store)) Task: Listen \u00b6 This task describes a connection intent, the actions that will to notify about connection status, and the action that will notify of incoming messages. { type: 'socket', op: 'listen', url: string, // socket endpoint URL, e.g. wss://example.com/ actions: { connect: string, // action type to dispatch when the socket connects disconnect: string, // action type to dispatch when the socket disconnects error: string, // action type to dispatch when an error occurs message: string, // action type to dispatch when a message is received } } Tip To disconnect a socket, simply remove the task (see how in the example ). Actions \u00b6 Event Type Meta Payload connect None None disconnect None None error None None message None Received message Task: Send \u00b6 { type: 'socket', op: 'send', data: any, // data to send, will be encoded to JSON actions: { sent: string // action type to dispatch when the message has been sent } } Warning The sent action can be a dummy (it doesn\u2019t need to be handled by any reducer) but needs to be dispatched, and thus specified, because it will signal to the task reducer that the send task can be removed from the store. This requirement will be lifted in future versions. Actions \u00b6 Name Meta Payload sent None Note Example \u00b6 Run this example \u00bb import { addTask, delTasks, reduceReducers, taskReducer } from 'redux-agent' const MAX_EVENTS = 4 const reducer = (state, action) => { switch (action.type) { case 'CONNECT_WEB_SOCKET': return addTask(state, { type: 'socket', op: 'listen', url: 'wss://ws-beta.kraken.com/', actions: { connect: 'SOCKET_CONNECTED', disconnect: 'SOCKET_DISCONNECTED', error: 'SOCKET_ERROR', message: 'SOCKET_MESSAGE_RECEIVED' } }) case 'SUBSCRIBE_TO_CURRENCY_INFO': return addTask(state, { type: 'socket', op: 'send', data: { event: 'subscribe', pair: ['XBT/USD', 'XBT/EUR'], subscription: { name: 'ticker' } }, actions: { sent: 'SOCKET_MESSAGE_SENT' } }) case 'DISCONNECT_WEB_SOCKET': return delTasks(state, (t) => t.type === 'socket') case 'SOCKET_MESSAGE_RECEIVED': const { events } = state.liveCurrencyUpdates return { ...state, liveCurrencyUpdates: { ...state.liveCurrencyUpdates, events: events.length < MAX_EVENTS ? events.concat(action.payload) : events.slice(0, -1).concat(action.payload) } } default: return state } } export default reduceReducers(reducer, taskReducer)","title":"WebSocket"},{"location":"reference/websocket/#configuration","text":"Parameter Type Description socketFactory (connectionUrl: string) => WebSocketLike Optional. Function that will be used to create the socket, useful to provide compatibility layers (e.g. Primus, SockJS) or enhanced versions of WebSocket. Defaults to creating a standard WebSocket encode (data: any) => any Optional. Function to encode data from a send task into a wire format. Defaults to JSON.stringify decode (data: any) => any Optional. Function to decode data from the wire into a format useful for application code. Defaults to JSON.parse Example: import ReconnectingWebSocket from 'reconnecting-websocket' import { configureAgents, createSocketAgent } from 'redux-agent' store.subscribe(configureAgents([ createSocketAgent({ // Provide enhanced/wrapped implementation socketFactory: (url) => new ReconnectingWebSocket(url) // skip JSON encoding encode: (data) => data, // skip JSON decoding decode: (data) => data }) ], store))","title":"Configuration"},{"location":"reference/websocket/#task-listen","text":"This task describes a connection intent, the actions that will to notify about connection status, and the action that will notify of incoming messages. { type: 'socket', op: 'listen', url: string, // socket endpoint URL, e.g. wss://example.com/ actions: { connect: string, // action type to dispatch when the socket connects disconnect: string, // action type to dispatch when the socket disconnects error: string, // action type to dispatch when an error occurs message: string, // action type to dispatch when a message is received } } Tip To disconnect a socket, simply remove the task (see how in the example ).","title":"Task: Listen"},{"location":"reference/websocket/#actions","text":"Event Type Meta Payload connect None None disconnect None None error None None message None Received message","title":"Actions"},{"location":"reference/websocket/#task-send","text":"{ type: 'socket', op: 'send', data: any, // data to send, will be encoded to JSON actions: { sent: string // action type to dispatch when the message has been sent } } Warning The sent action can be a dummy (it doesn\u2019t need to be handled by any reducer) but needs to be dispatched, and thus specified, because it will signal to the task reducer that the send task can be removed from the store. This requirement will be lifted in future versions.","title":"Task: Send"},{"location":"reference/websocket/#actions_1","text":"Name Meta Payload sent None Note","title":"Actions"},{"location":"reference/websocket/#example","text":"Run this example \u00bb import { addTask, delTasks, reduceReducers, taskReducer } from 'redux-agent' const MAX_EVENTS = 4 const reducer = (state, action) => { switch (action.type) { case 'CONNECT_WEB_SOCKET': return addTask(state, { type: 'socket', op: 'listen', url: 'wss://ws-beta.kraken.com/', actions: { connect: 'SOCKET_CONNECTED', disconnect: 'SOCKET_DISCONNECTED', error: 'SOCKET_ERROR', message: 'SOCKET_MESSAGE_RECEIVED' } }) case 'SUBSCRIBE_TO_CURRENCY_INFO': return addTask(state, { type: 'socket', op: 'send', data: { event: 'subscribe', pair: ['XBT/USD', 'XBT/EUR'], subscription: { name: 'ticker' } }, actions: { sent: 'SOCKET_MESSAGE_SENT' } }) case 'DISCONNECT_WEB_SOCKET': return delTasks(state, (t) => t.type === 'socket') case 'SOCKET_MESSAGE_RECEIVED': const { events } = state.liveCurrencyUpdates return { ...state, liveCurrencyUpdates: { ...state.liveCurrencyUpdates, events: events.length < MAX_EVENTS ? events.concat(action.payload) : events.slice(0, -1).concat(action.payload) } } default: return state } } export default reduceReducers(reducer, taskReducer)","title":"Example"}]}